# PyLua Refactoring Plan: Introducing Bytecode

This document outlines the steps to refactor PyLua from a direct source-to-execution model to a compile-to-bytecode and then execute-bytecode model. This change will be done in the PyLua0.2 folder inside src.

## Phase 1: Core Bytecode Implementation

### 0. Directory Structure for PyLua0.2

The new code for version 0.2 will be organized within the `src/PyLua0.2/` folder as follows (can change and will):

```txt
src/PyLua0.2/
â”œâ”€â”€ compiler/               # Python code -> Bytecode
â”‚   â”œâ”€â”€ tokenizer.luau
â”‚   â”œâ”€â”€ parser.luau             # Or bytecode_generator.luau
â”‚   â””â”€â”€ control_flow_compiler.luau
â”œâ”€â”€ vm/                     # Bytecode execution
â”‚   â”œâ”€â”€ bytecode_executor.luau
â”‚   â””â”€â”€ opcodes.luau            # Bytecode instruction definitions
â”œâ”€â”€ core/                   # Shared utilities
â”‚   â”œâ”€â”€ variables.luau
â”‚   â””â”€â”€ builtins.luau
â””â”€â”€ python.luau             # Main public API for PyLua 0.2
```

### 1. Define Bytecode Structure

- [X] Define the Luau table structure for bytecode (constants, names, code with opcodes and arguments).

```lua
local bytecode_example = {
    constants = {
        "Hello from Python!",  -- 0
        85,                    -- 1
        -- ... more constants
    },
    names = {
        "message",             -- 0
        "score",               -- 1
        -- ... more variable/function names
    },
    code = {
        {op="LOAD_CONST", arg=0},
        {op="STORE_NAME", arg=0},  -- message
        -- ... more operations
    }
}
```

### 2. Bytecode Interpreter

- [x] Create `src/PyLua0.2/vm/opcodes.luau` to define bytecode instruction set and structure.
- [x] Create a new module (`src/PyLua0.2/vm/bytecode_executor.luau`) to execute the bytecode.
- [x] Implement a dispatch loop that reads and executes bytecode operations one by one.
- [x] Implement handlers for each defined opcode:
- [x] `LOAD_CONST`: Load a constant onto an internal stack.
- [x] `STORE_NAME`: Store a value from the stack into a variable.
- [x] `LOAD_NAME`: Load a variable's value onto the stack.
- [x] `CALL_FUNCTION`: Call a function (using `src/PyLua0.2/core/builtins.luau` or user-defined functions).
- [x] `BINARY_OP`: Perform binary operations.
- [x] `COMPARE_OP`: Perform comparison operations.
- [x] `JUMP_IF_FALSE`: Conditional jump.
- [x] `JUMP`: Unconditional jump.
- [x] `GET_ITER`: Get iterator from iterable for for-loops.
- [x] `FOR_ITER`: Iterate through iterator, jump to end when exhausted.
- [x] `BINARY_ADD`, `BINARY_SUB`, `BINARY_MUL`, `BINARY_DIV`, `BINARY_MOD`: Arithmetic operations.
- [x] `COMPARE_LT`, `COMPARE_GT`, `COMPARE_EQ`, `COMPARE_NE`, `COMPARE_LE`, `COMPARE_GE`: Comparison operations.
- [x] Manage an execution stack for operands and function calls.
- [x] Interface with `src/PyLua0.2/core/builtins.luau` for calling built-in functions.

### 3. Bytecode Compiler

- [x] **Tokenizer (`src/PyLua0.2/compiler/tokenizer.luau`):** Review and ensure it provides tokens suitable for the new parser/compiler. (Fully implemented with Python syntax support).
- [x] **Parser to Bytecode Emitter (`src/PyLua0.2/compiler/compiler.luau`):** (Renamed from parser.luau)
- [x] Modify the existing parser to traverse the Abstract Syntax Tree (AST) and emit bytecode instructions instead of directly preparing for evaluation.
- [x] Implement logic to populate `constants` and `names` tables during compilation.
- [x] Handle basic expressions (literals, variable lookups).
- [x] Handle assignment statements (`STORE_NAME`).
- [x] Handle function calls (`CALL_FUNCTION`).
- [x] Handle arithmetic and comparison operations (`BINARY_OP`, `COMPARE_OP`).
- [x] **Control Flow Compiler (integrated into `src/PyLua0.2/compiler/compiler.luau`):**
- [x] Adapt `if/else/elif` statements to generate conditional jump opcodes (`JUMP_IF_FALSE`, `JUMP`).
- [x] Adapt `for` loops to generate appropriate loop setup and jump opcodes (`GET_ITER`, `FOR_ITER`).
- [x] Adapt `while` loops to generate appropriate loop setup and jump opcodes (`JUMP_IF_FALSE`, `JUMP`).
- [x] Handle nested control structures (if inside loops, loops inside if, etc.).

### 4. Update Main API (`src/PyLua0.2/python.luau`)

- [x] **`Python.compile(sourceString: string): bytecodeTable` function (in `src/PyLua0.2/python.luau`):**
- [x] Takes Python source code as a string.
- [x] Uses the modified parser/new compiler (from `src/PyLua0.2/compiler/`) to generate the bytecode table.
- [x] Returns the bytecode table.
- [x] **`Python.runBytecode(bytecodeTable: table): any` function (in `src/PyLua0.2/python.luau`):**
- [x] Takes a bytecode table (as generated by `compile`).
- [x] Uses the new bytecode interpreter (from `src/PyLua0.2/vm/`) to execute the code.
- [x] Returns the result of the execution (if any, similar to how `getVariable` might work or the last expression's value).
- [x] **Modify `Python.execute(sourceString: string): any` function (in `src/PyLua0.2/python.luau`):**
- [x] Internally call `Python.compile(sourceString)`.
- [x] Then call `Python.runBytecode()` to execute the compiled bytecode.

## âœ… PHASE 1 COMPLETE - Additional Achievements

Beyond the original plan, it was also implemented:

### Core Language Features

- [x] **Python Boolean Constants:** Added `True`, `False`, and `None` to built-ins
- [x] **Enhanced Built-in Functions:** Updated all built-ins (`print`, `range`, `len`, `type`, `str`, `int`, `float`, `bool`) to use varargs pattern compatible with bytecode executor
- [x] **Complete Python Object System:** Implemented lists, dictionaries, tuples, and sets with proper Python semantics

### Advanced Control Flow

- [x] **Full Nesting Support:** Complex nested control structures (loops in conditionals, conditionals in loops, multiple levels)
- [x] **Block-Aware Compilation:** Recursive compilation of nested control structures

### Error Handling & Debugging

- [x] **Enhanced Error Reporting:** Detailed error messages with line numbers and suggestions
- [x] **Debug Mode:** Step-by-step execution tracing with stack visualization
- [x] **Comprehensive Error Types:** NameError, TypeError, ZeroDivisionError with proper Python semantics

### Testing & Validation

- [x] **Comprehensive Test Suite:** 100% test coverage for all implemented features
- [x] **Nested Control Flow Tests:** 7 complex scenarios testing all combinations
- [x] **Error Condition Tests:** Verification of proper error handling
- [x] **Object System Tests:** Full validation of Python data structures

## ðŸŽ¯ Current Status: DEV READY

The PyLua 0.2 bytecode virtual machine is functional with:

- âœ… Complete Python control flow (if/elif/else, for, while, nested structures)
- âœ… Full Python object system (lists, dicts, tuples, sets, method chaining)  
- âœ… Comprehensive built-in functions
- âœ… Robust error handling with debugging support
- âœ… 100% test success rate across all implemented features

**Next phases can focus on:** Function definitions, classes, modules, exception handling, and advanced Python features.
