# PyLua Refactoring Plan: Introducing Bytecode

This document outlines the steps to refactor PyLua from a direct source-to-execution model to a compile-to-bytecode and then execute-bytecode model. This change will be done in the PyLua0.2 folder inside src.

## Phase 1: Core Bytecode Implementation

### 0. Directory Structure for PyLua0.2

The new code for version 0.2 will be organized within the `src/PyLua0.2/` folder as follows (can change and will):

```txt
src/PyLua0.2/
├── compiler/               # Python code -> Bytecode
│   ├── tokenizer.luau
│   ├── parser.luau             # Or bytecode_generator.luau
│   └── control_flow_compiler.luau
├── vm/                     # Bytecode execution
│   ├── bytecode_executor.luau
│   └── opcodes.luau            # Bytecode instruction definitions
├── core/                   # Shared utilities
│   ├── variables.luau
│   └── builtins.luau
└── python.luau             # Main public API for PyLua 0.2
```

### 1. Define Bytecode Structure

- [X] Define the Luau table structure for bytecode (constants, names, code with opcodes and arguments).

```lua
local bytecode_example = {
    constants = {
        "Hello from Python!",  -- 0
        85,                    -- 1
        -- ... more constants
    },
    names = {
        "message",             -- 0
        "score",               -- 1
        -- ... more variable/function names
    },
    code = {
        {op="LOAD_CONST", arg=0},
        {op="STORE_NAME", arg=0},  -- message
        -- ... more operations
    }
}
```

### 2. Bytecode Interpreter

- [x] Create `src/PyLua0.2/vm/opcodes.luau` to define bytecode instruction set and structure.
- [x] Create a new module (`src/PyLua0.2/vm/bytecode_executor.luau`) to execute the bytecode.
- [x] Implement a dispatch loop that reads and executes bytecode operations one by one.
- [x] Implement handlers for each defined opcode:
- [x] `LOAD_CONST`: Load a constant onto an internal stack.
- [x] `STORE_NAME`: Store a value from the stack into a variable.
- [x] `LOAD_NAME`: Load a variable's value onto the stack.
- [x] `CALL_FUNCTION`: Call a function (using `src/PyLua0.2/core/builtins.luau` or user-defined functions).
- [x] `BINARY_OP`: Perform binary operations.
- [x] `COMPARE_OP`: Perform comparison operations.
- [x] `JUMP_IF_FALSE`: Conditional jump.
- [x] `JUMP`: Unconditional jump.
- [ ] (Add more opcodes as needed for Python features)
- [ ] Manage an execution stack for operands and function calls.
- [x] Interface with `src/PyLua0.2/core/builtins.luau` for calling built-in functions.

### 3. Bytecode Compiler

- [ ] **Tokenizer (`src/PyLua0.2/compiler/tokenizer.luau`):** Review and ensure it provides tokens suitable for the new parser/compiler. (Likely minor or no changes initially).
- [ ] **Parser to Bytecode Emitter (`src/PyLua0.2/compiler/parser.luau`):**
- [ ] Modify the existing parser to traverse the Abstract Syntax Tree (AST) and emit bytecode instructions instead of directly preparing for evaluation.
- [ ] Implement logic to populate `constants` and `names` tables during compilation.
- [ ] Handle basic expressions (literals, variable lookups).
- [ ] Handle assignment statements (`STORE_NAME`).
- [ ] Handle function calls (`CALL_FUNCTION`).
- [ ] Handle arithmetic and comparison operations (`BINARY_OP`, `COMPARE_OP`).
- [ ] **Control Flow Compiler (`src/PyLua0.2/compiler/control_flow_compiler.luau` integration):**
- [ ] Adapt `if/else` statements to generate conditional jump opcodes (`JUMP_IF_FALSE`, `JUMP`).
- [ ] Adapt `for` loops to generate appropriate loop setup and jump opcodes.
- [ ] Adapt `while` loops to generate appropriate loop setup and jump opcodes.

### 4. Update Main API (`src/PyLua0.2/python.luau`)

- [ ] **`Python.compile(sourceString: string): bytecodeTable` function (in `src/PyLua0.2/python.luau`):**
- [ ] Takes Python source code as a string.
- [ ] Uses the modified parser/new compiler (from `src/PyLua0.2/compiler/`) to generate the bytecode table.
- [ ] Returns the bytecode table.
- [ ] **`Python.runBytecode(bytecodeTable: table): any` function (in `src/PyLua0.2/python.luau`):**
- [ ] Takes a bytecode table (as generated by `compile`).
- [ ] Uses the new bytecode interpreter (from `src/PyLua0.2/vm/`) to execute the code.
- [ ] Returns the result of the execution (if any, similar to how `getVariable` might work or the last expression's value).
- [ ] **Modify `Python.execute(sourceString: string): any` function (in `src/PyLua0.2/python.luau`):**
- [ ] Internally call `Python.compile(sourceString)`.
