-- PyLua Compiler State Management
-- Handles creation and management of compiler state

local types = require('../../core/types')

type CompilerState = types.CompilerState
type Instruction = types.Instruction
type Any = types.Any

local State = {}

-- Create a new compiler state
function State.createCompilerState(): CompilerState
    return {
        constants = {},      -- Constants table
        names = {},          -- Variable/function names table
        code = {},           -- Generated bytecode instructions
        constantsMap = {},   -- Map to avoid duplicate constants
        namesMap = {},       -- Map to avoid duplicate names
        lineNumber = 1,      -- Current line number for debugging
    }
end

-- Add a constant to the constants table and return its index
function State.addConstant(state: CompilerState, value: Any): number
    -- Use value itself as key for primitives, handle nil and tables separately  
    local key
    if value == nil then
        key = "__NIL__"
    elseif type(value) == "table" then
        key = tostring(value)  -- Use table's memory address as key
    else
        key = value  -- Use the value directly as key for primitives
    end
    
    if state.constantsMap[key] then
        return state.constantsMap[key]
    end
    
    -- Handle nil values specially since Lua tables ignore nil values
    if value == nil then
        table.insert(state.constants, "__PYLUA_NIL__")  -- Use placeholder for nil
    else
        table.insert(state.constants, value)
    end
    local index = #state.constants - 1  -- 0-based indexing
    state.constantsMap[key] = index
    return index
end

-- Add a name to the names table and return its index
function State.addName(state: CompilerState, name: string): number
    if state.namesMap[name] then
        return state.namesMap[name]
    end
    
    table.insert(state.names, name)
    local index = #state.names - 1  -- 0-based indexing
    state.namesMap[name] = index
    return index
end

-- Emit a bytecode instruction
function State.emit(state: CompilerState, opcode: string, arg: number?, line: number?): number
    local instruction: Instruction = {
        op = opcode,
        arg = arg,
        line = line or state.lineNumber
    }
    table.insert(state.code, instruction)
    return #state.code - 1  -- Return instruction index for jumps
end

return State
