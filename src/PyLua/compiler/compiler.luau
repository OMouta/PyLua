-- PyLua Bytecode Compiler
-- Compiles Python source code to PyLua bytecode
-- This replaces the direct evaluation approach with bytecode generation

local Compiler = {}
local opcodes = require('../vm/opcodes')
local tokenizer = require('./tokenizer')
local types = require('../core/types')

type CompilerState = types.CompilerState
type Instruction = types.Instruction
type Bytecode = types.Bytecode
type TokenPosition = types.TokenPosition
type Any = types.Any

-- Compiler state
local function createCompilerState(): CompilerState
    return {
        constants = {},      -- Constants table
        names = {},          -- Variable/function names table
        code = {},           -- Generated bytecode instructions
        constantsMap = {},   -- Map to avoid duplicate constants
        namesMap = {},       -- Map to avoid duplicate names
        lineNumber = 1,      -- Current line number for debugging
    }
end

-- Add a constant to the constants table and return its index
local function addConstant(state: CompilerState, value: Any): number
    local key = tostring(value) .. "_" .. type(value)
    if state.constantsMap[key] then
        return state.constantsMap[key]
    end
    
    -- Handle nil values specially since Lua tables ignore nil values
    if value == nil then
        table.insert(state.constants, "__PYLUA_NIL__")  -- Use placeholder for nil
    else
        table.insert(state.constants, value)
    end
    local index = #state.constants - 1  -- 0-based indexing
    state.constantsMap[key] = index
    return index
end

-- Add a name to the names table and return its index
local function addName(state: CompilerState, name: string): number
    if state.namesMap[name] then
        return state.namesMap[name]
    end
    
    table.insert(state.names, name)
    local index = #state.names - 1  -- 0-based indexing
    state.namesMap[name] = index
    return index
end

-- Emit a bytecode instruction
local function emit(state: CompilerState, opcode: string, arg: number?, line: number?): number
    local instruction: Instruction = {
        op = opcode,
        arg = arg,
        line = line or state.lineNumber
    }
    table.insert(state.code, instruction)
    return #state.code - 1  -- Return instruction index for jumps
end

-- Parse a number literal
local function parseNumber(token: string): number
    local num = tonumber(token)
    if num then
        return num
    end
    error("Invalid number: " .. tostring(token))
end

-- Parse a string literal
local function parseString(token: string): string
    -- Remove quotes and return the string content
    if (token:sub(1, 1) == "\"" and token:sub(-1, -1) == "\"") or
       (token:sub(1, 1) == "'" and token:sub(-1, -1) == "'") then
        return token:sub(2, -2)
    end
    error("Invalid string: " .. tostring(token))
end

-- Check if a token is a number
local function isNumber(token: string): boolean
    return tonumber(token) ~= nil
end

-- Check if a token is a string literal
local function isString(token: string): boolean
    return (token:sub(1, 1) == "\"" and token:sub(-1, -1) == "\"") or
           (token:sub(1, 1) == "'" and token:sub(-1, -1) == "'")
end

-- Check if a token is an identifier
local function isIdentifier(token: string): boolean
    return token:match("^[a-zA-Z_][a-zA-Z0-9_]*$") ~= nil
end

-- Check if a token is a binary operator
local function isBinaryOperator(token: string): boolean
    return token == "+" or token == "-" or token == "*" or token == "/" or 
           token == "%" or token == "==" or token == "!=" or token == "<" or
           token == ">" or token == "<=" or token == ">="
end

-- Get operator precedence (higher number = higher precedence)
local function getOperatorPrecedence(op: string): number
    if op == "==" or op == "!=" or op == "<" or op == ">" or op == "<=" or op == ">=" then
        return 1
    elseif op == "+" or op == "-" then
        return 2
    elseif op == "*" or op == "/" or op == "%" then
        return 3
    end
    return 0
end

-- Check if a line has unclosed delimiters (for multi-line statements)
local function hasUnclosedDelimiters(tokens: {string}): boolean
    local openParens = 0
    local openBrackets = 0
    local openBraces = 0
    
    for _, token in ipairs(tokens) do
        if token == "(" then
            openParens = openParens + 1
        elseif token == ")" then
            openParens = openParens - 1
        elseif token == "[" then
            openBrackets = openBrackets + 1
        elseif token == "]" then
            openBrackets = openBrackets - 1
        elseif token == "{" then
            openBraces = openBraces + 1
        elseif token == "}" then
            openBraces = openBraces - 1
        end
    end
    
    return openParens > 0 or openBrackets > 0 or openBraces > 0
end

-- Collect multi-line statement tokens (for object literals spanning multiple lines)
local function collectMultiLineStatement(lines: {string}, startLine: number): ({string}, number)
    local allTokens: {string} = {}
    local currentLine = startLine
    
    while currentLine <= #lines do
        local line = lines[currentLine]
        local trimmed = line:match("^%s*(.-)%s*$") or ""
        
        if trimmed ~= "" and not trimmed:match("^#") then
            local lineTokens = tokenizer.tokenize(trimmed)
            for _, token in ipairs(lineTokens) do
                table.insert(allTokens, token)
            end
            
            -- Check if statement is now complete
            if not hasUnclosedDelimiters(allTokens) then
                break
            end
        end
        
        currentLine = currentLine + 1
    end
    
    return allTokens, currentLine
end

-- Forward declarations
local compileExpression: (CompilerState, {string}, TokenPosition) -> TokenPosition
local compileStatement: (CompilerState, {string}, TokenPosition) -> TokenPosition

-- Compile a primary expression (numbers, strings, identifiers, parenthesized expressions)
local function compilePrimary(state: CompilerState, tokens: {string}, pos: TokenPosition): TokenPosition
    local token = tokens[pos]
    
    if not token then
        error("Unexpected end of expression")
    end
    
    if isNumber(token) then
        -- Number literal
        local value = parseNumber(token)
        local constIndex = addConstant(state, value)
        emit(state, opcodes.Opcodes.LOAD_CONST, constIndex)
        return pos + 1
    elseif isString(token) then
        -- String literal
        local value = parseString(token)
        local constIndex = addConstant(state, value)
        emit(state, opcodes.Opcodes.LOAD_CONST, constIndex)
        return pos + 1
    elseif token == "True" then
        -- Python True literal
        local constIndex = addConstant(state, true)
        emit(state, opcodes.Opcodes.LOAD_CONST, constIndex)
        return pos + 1
    elseif token == "False" then
        -- Python False literal
        local constIndex = addConstant(state, false)
        emit(state, opcodes.Opcodes.LOAD_CONST, constIndex)
        return pos + 1
    elseif token == "None" then
        -- Python None literal
        local constIndex = addConstant(state, nil)
        emit(state, opcodes.Opcodes.LOAD_CONST, constIndex)
        return pos + 1
    elseif isIdentifier(token) then
        -- Variable or function name
        local nameIndex = addName(state, token)
        emit(state, opcodes.Opcodes.LOAD_NAME, nameIndex)
        return pos + 1
    elseif token == "(" then
        -- Parenthesized expression or tuple
        pos = pos + 1
        
        -- Check for empty tuple
        if tokens[pos] == ")" then
            emit(state, opcodes.Opcodes.BUILD_TUPLE, 0)
            return pos + 1
        end
        
        -- Parse first expression
        pos = compileExpression(state, tokens, pos)
        
        -- Check if it's a tuple (has comma) or just parenthesized expression
        if tokens[pos] == "," then
            local elementCount = 1
            pos = pos + 1
            
            -- Parse remaining elements
            while tokens[pos] and tokens[pos] ~= ")" do
                pos = compileExpression(state, tokens, pos)
                elementCount = elementCount + 1
                
                if tokens[pos] == "," then
                    pos = pos + 1
                elseif tokens[pos] ~= ")" then
                    error("Expected ',' or ')' in tuple")
                end
            end
            
            if tokens[pos] ~= ")" then
                error("Expected ')' after tuple")
            end
            
            emit(state, opcodes.Opcodes.BUILD_TUPLE, elementCount)
            return pos + 1
        else
            -- Just a parenthesized expression
            if tokens[pos] ~= ")" then
                error("Expected ')' after expression")
            end
            return pos + 1
        end
    elseif token == "[" then
        -- List literal
        pos = pos + 1
        local elementCount = 0
        
        -- Handle empty list
        if tokens[pos] == "]" then
            emit(state, opcodes.Opcodes.BUILD_LIST, 0)
            return pos + 1
        end
        
        -- Parse list elements
        while tokens[pos] and tokens[pos] ~= "]" do
            pos = compileExpression(state, tokens, pos)
            elementCount = elementCount + 1
            
            if tokens[pos] == "," then
                pos = pos + 1
            elseif tokens[pos] ~= "]" then
                error("Expected ',' or ']' in list")
            end
        end
        
        if tokens[pos] ~= "]" then
            error("Expected ']' after list")
        end
        
        emit(state, opcodes.Opcodes.BUILD_LIST, elementCount)
        return pos + 1
    elseif token == "{" then
        -- Dictionary or set literal
        pos = pos + 1
          -- Handle empty dict/set
        if tokens[pos] == "}" then
            -- Empty dict (Python convention: {} is dict, set() is empty set)
            emit(state, opcodes.Opcodes.BUILD_DICT, 0)
            return pos + 1
        end
        
        -- Parse first element to determine if it's a dict or set
        local firstExprPos = pos
        pos = compileExpression(state, tokens, pos)
        if tokens[pos] == ":" then
            -- Dictionary - we have key:value pairs
            -- The first key was already compiled, now compile its value
            pos = pos + 1  -- skip ':'
            pos = compileExpression(state, tokens, pos)  -- compile value
            local pairCount = 1
            
            -- Parse remaining key-value pairs
            while pos <= #tokens and tokens[pos] == "," do
                pos = pos + 1
                if pos <= #tokens and tokens[pos] == "}" then
                    break  -- trailing comma
                end
                pos = compileExpression(state, tokens, pos)  -- key
                if pos > #tokens or tokens[pos] ~= ":" then
                    error("Expected ':' after dictionary key")
                end
                pos = pos + 1  -- skip ':'
                pos = compileExpression(state, tokens, pos)  -- value
                pairCount = pairCount + 1
            end
            
            if pos > #tokens or tokens[pos] ~= "}" then
                error("Expected '}' after dictionary")
            end
            
            emit(state, opcodes.Opcodes.BUILD_DICT, pairCount)
            return pos + 1
        else
            -- Set - we have individual values
            local elementCount = 1
              -- Parse remaining elements
            while pos <= #tokens and tokens[pos] == "," do
                pos = pos + 1
                if pos <= #tokens and tokens[pos] == "}" then
                    break  -- trailing comma
                end
                
                pos = compileExpression(state, tokens, pos)
                elementCount = elementCount + 1
            end
            
            if pos > #tokens or tokens[pos] ~= "}" then
                error("Expected '}' after set")
            end
            
            emit(state, opcodes.Opcodes.BUILD_SET, elementCount)
            return pos + 1
        end
    else
        error("Unexpected token in expression: " .. token)
    end
end

-- Compile a function call
local function compileFunctionCall(state: CompilerState, tokens: {string}, pos: TokenPosition): TokenPosition
    -- The function name should already be loaded onto the stack
    
    if tokens[pos] ~= "(" then
        error("Expected '(' for function call")
    end
    pos = pos + 1
    
    local argCount = 0
    
    -- Parse arguments
    while tokens[pos] and tokens[pos] ~= ")" do
        if argCount > 0 then
            if tokens[pos] ~= "," then
                error("Expected ',' between function arguments")
            end
            pos = pos + 1
        end
        
        pos = compileExpression(state, tokens, pos)
        argCount = argCount + 1
    end
    
    if tokens[pos] ~= ")" then
        error("Expected ')' after function arguments")
    end
    pos = pos + 1
    
    -- Emit function call instruction
    emit(state, opcodes.Opcodes.CALL_FUNCTION, argCount)
    
    return pos
end

-- Compile a binary expression with operator precedence
compileExpression = function(state: CompilerState, tokens: {string}, pos: TokenPosition): TokenPosition
    -- Check bounds
    if pos > #tokens then
        error("Unexpected end of expression")
    end
    
    -- Parse the left operand
    pos = compilePrimary(state, tokens, pos)
      -- Handle postfix operations (function calls, indexing, attribute access)
    while tokens[pos] do
        if tokens[pos] == "(" then
            -- Function call
            pos = compileFunctionCall(state, tokens, pos)
        elseif tokens[pos] == "[" then
            -- Array/dictionary indexing
            pos = pos + 1  -- Skip '['
            
            -- Compile the index expression
            pos = compileExpression(state, tokens, pos)
            
            -- Expect ']'
            if tokens[pos] ~= "]" then
                error("Expected ']' after index expression")
            end
            pos = pos + 1  -- Skip ']'
            
            -- Emit indexing bytecode
            emit(state, opcodes.Opcodes.BINARY_SUBSCR)
        elseif tokens[pos] == "." then
            -- Attribute access (obj.attr)
            pos = pos + 1  -- Skip '.'
            
            if not tokens[pos] or not isIdentifier(tokens[pos]) then
                error("Expected attribute name after '.'")
            end
            
            local attrName = tokens[pos]
            pos = pos + 1
            
            -- Add attribute name to names table and emit LOAD_ATTR
            local nameIndex = addName(state, attrName)
            emit(state, opcodes.Opcodes.LOAD_ATTR, nameIndex)
        else
            break  -- No more postfix operations
        end
    end
    
    -- Handle binary operators with precedence
    while tokens[pos] and isBinaryOperator(tokens[pos]) do
        local operator = tokens[pos]
        local precedence = getOperatorPrecedence(operator)
        pos = pos + 1
          -- Parse right operand
        pos = compilePrimary(state, tokens, pos)
          -- Handle postfix operations on right operand (function calls, indexing, attribute access)
        while tokens[pos] do
            if tokens[pos] == "(" then
                pos = compileFunctionCall(state, tokens, pos)
            elseif tokens[pos] == "[" then
                pos = pos + 1  -- Skip '['
                pos = compileExpression(state, tokens, pos)
                if tokens[pos] ~= "]" then
                    error("Expected ']' after index expression")
                end
                pos = pos + 1  -- Skip ']'
                emit(state, opcodes.Opcodes.BINARY_SUBSCR)
            elseif tokens[pos] == "." then
                pos = pos + 1  -- Skip '.'
                if not tokens[pos] or not isIdentifier(tokens[pos]) then
                    error("Expected attribute name after '.'")
                end
                local attrName = tokens[pos]
                pos = pos + 1
                local nameIndex = addName(state, attrName)
                emit(state, opcodes.Opcodes.LOAD_ATTR, nameIndex)
            else
                break
            end
        end
        
        -- Emit the appropriate binary operation
        if operator == "+" then
            emit(state, opcodes.Opcodes.BINARY_ADD)
        elseif operator == "-" then
            emit(state, opcodes.Opcodes.BINARY_SUB)
        elseif operator == "*" then
            emit(state, opcodes.Opcodes.BINARY_MUL)
        elseif operator == "/" then
            emit(state, opcodes.Opcodes.BINARY_DIV)
        elseif operator == "%" then
            emit(state, opcodes.Opcodes.BINARY_MOD)
        elseif operator == "==" then
            emit(state, opcodes.Opcodes.COMPARE_EQ)
        elseif operator == "!=" then
            emit(state, opcodes.Opcodes.COMPARE_NE)
        elseif operator == "<" then
            emit(state, opcodes.Opcodes.COMPARE_LT)
        elseif operator == ">" then
            emit(state, opcodes.Opcodes.COMPARE_GT)
        elseif operator == "<=" then
            emit(state, opcodes.Opcodes.COMPARE_LE)
        elseif operator == ">=" then
            emit(state, opcodes.Opcodes.COMPARE_GE)
        else
            error("Unknown binary operator: " .. operator)
        end
    end
    
    return pos
end

-- Compile an assignment statement
local function compileAssignment(state: CompilerState, tokens: {string}, pos: TokenPosition): TokenPosition
    -- Parse the left-hand side to determine assignment type
    local startPos = pos
    
    -- Check if it's a simple variable assignment (var = ...) or indexing assignment (obj[key] = ...)
    if isIdentifier(tokens[pos]) and tokens[pos + 1] == "=" then
        -- Simple variable assignment: var = value
        local varName = tokens[pos]
        pos = pos + 2  -- Skip variable name and '='
        
        -- Compile the right-hand side expression
        pos = compileExpression(state, tokens, pos)
        
        -- Store the value in the variable
        local nameIndex = addName(state, varName)
        emit(state, opcodes.Opcodes.STORE_NAME, nameIndex)
        
        return pos
    else
        -- Check for indexing assignment: obj[key] = value
        local savedPos = pos
        local foundIndexing = false
        local equalsPos = nil
        
        -- Scan to find the assignment pattern
        while pos <= #tokens do
            if tokens[pos] == "=" then
                equalsPos = pos
                break
            elseif tokens[pos] == "[" then
                foundIndexing = true
            end
            pos = pos + 1
        end
        
        if foundIndexing and equalsPos then
            -- Indexing assignment: obj[key] = value
            pos = savedPos
            
            -- Compile the object expression (everything before '[')
            local objStart = pos
            while tokens[pos] and tokens[pos] ~= "[" do
                pos = pos + 1
            end
            
            -- Compile object expression
            local objTokens = {}
            for i = objStart, pos - 1 do
                table.insert(objTokens, tokens[i])
            end
            compileExpression(state, objTokens, 1)
            
            -- Skip '['
            if tokens[pos] ~= "[" then
                error("Expected '[' in indexing assignment")
            end
            pos = pos + 1
            
            -- Compile the index expression
            local indexStart = pos
            local bracketCount = 1
            while tokens[pos] and bracketCount > 0 do
                if tokens[pos] == "[" then
                    bracketCount = bracketCount + 1
                elseif tokens[pos] == "]" then
                    bracketCount = bracketCount - 1
                end
                if bracketCount > 0 then
                    pos = pos + 1
                end
            end
            
            local indexTokens = {}
            for i = indexStart, pos - 1 do
                table.insert(indexTokens, tokens[i])
            end
            compileExpression(state, indexTokens, 1)
            
            -- Skip ']'
            if tokens[pos] ~= "]" then
                error("Expected ']' in indexing assignment")
            end
            pos = pos + 1
            
            -- Skip '='
            if tokens[pos] ~= "=" then
                error("Expected '=' in indexing assignment")
            end
            pos = pos + 1
            
            -- Compile the right-hand side expression
            pos = compileExpression(state, tokens, pos)
            
            -- Emit store subscript instruction
            emit(state, opcodes.Opcodes.STORE_SUBSCR)
            
            return pos
        else
            error("Invalid assignment statement")
        end
    end
end

-- Forward declarations for block compilation functions
local compileIfStatementBlock
local compileWhileLoopBlock  
local compileForLoopBlock
local compileFunctionDefinitionBlock

-- Function definition compilation functions
local function compileFunctionDefinition(state, tokens, pos)
    -- def function_name(param1, param2, ...):
    if tokens[pos] ~= "def" then
        error("Expected 'def' keyword")
    end
    pos = pos + 1
    
    -- Get function name
    local functionName = tokens[pos]
    if not isIdentifier(functionName) then
        error("Expected function name after 'def'")
    end
    pos = pos + 1
    
    -- Expect '('
    if tokens[pos] ~= "(" then
        error("Expected '(' after function name")
    end
    pos = pos + 1
    
    -- Parse parameters
    local parameters = {}
    while tokens[pos] and tokens[pos] ~= ")" do
        if #parameters > 0 then
            if tokens[pos] ~= "," then
                error("Expected ',' between function parameters")
            end
            pos = pos + 1
        end
        
        if not isIdentifier(tokens[pos]) then
            error("Expected parameter name")
        end
        
        table.insert(parameters, tokens[pos])
        pos = pos + 1
    end
    
    -- Expect ')'
    if tokens[pos] ~= ")" then
        error("Expected ')' after function parameters")
    end
    pos = pos + 1
    
    -- Expect ':'
    if tokens[pos] ~= ":" then
        error("Expected ':' after function signature")
    end
    pos = pos + 1
      -- For now, create a placeholder function object
    -- In a full implementation, we'd compile the function body as separate bytecode
    local nameIndex = addName(state, functionName)
    
    -- Create a placeholder bytecode structure
    local placeholderBytecode: Bytecode = {
        constants = {},
        names = {},
        code = {}
    }
    
    -- Create MAKE_FUNCTION instruction with function details
    local instruction: Instruction = {
        op = opcodes.Opcodes.MAKE_FUNCTION,
        name = functionName,
        parameters = parameters,
        bytecode = placeholderBytecode,
        defaults = {},
        closure = {},
        arg = nameIndex, -- Use nameIndex as the arg for consistency
        line = state.lineNumber
    }
    table.insert(state.code, instruction)
    
    -- Store function in variable
    emit(state, opcodes.Opcodes.STORE_NAME, nameIndex)
    
    return pos
end

compileFunctionDefinitionBlock = function(state: CompilerState, lines: {string}, startLine: number): number
    local line = lines[startLine]
    local trimmedLine = line:match("^%s*(.-)%s*$") or ""
    local tokens = tokenizer.tokenize(trimmedLine)
    
    -- Parse the function definition header
    local pos = 1
    if tokens[pos] ~= "def" then
        error("Expected 'def' keyword")
    end
    pos = pos + 1
    
    -- Get function name
    local functionName = tokens[pos]
    if not isIdentifier(functionName) then
        error("Expected function name after 'def'")
    end
    pos = pos + 1
    
    -- Expect '('
    if tokens[pos] ~= "(" then
        error("Expected '(' after function name")
    end
    pos = pos + 1
    
    -- Parse parameters
    local parameters = {}
    while tokens[pos] and tokens[pos] ~= ")" do
        if #parameters > 0 then
            if tokens[pos] ~= "," then
                error("Expected ',' between function parameters")
            end
            pos = pos + 1
        end
        
        if not isIdentifier(tokens[pos]) then
            error("Expected parameter name")
        end
        
        table.insert(parameters, tokens[pos])
        pos = pos + 1
    end
    
    -- Expect ')'
    if tokens[pos] ~= ")" then
        error("Expected ')' after function parameters")
    end
    pos = pos + 1
    
    -- Expect ':'
    if tokens[pos] ~= ":" then
        error("Expected ':' after function signature")
    end
    
    -- Create a new compiler state for the function body
    local functionState = createCompilerState()
    
    -- Compile the function body
    local currentLine = startLine + 1
    local baseIndent = nil
    
    while currentLine <= #lines do
        local blockLine = lines[currentLine]
        local indent = blockLine:match("^(%s*)") or ""
        local trimmed = blockLine:match("^%s*(.-)%s*$") or ""
        
        -- Skip empty lines
        if trimmed == "" then
            currentLine = currentLine + 1
        elseif #indent > 0 then
            -- First indented line sets the base indentation
            if not baseIndent then
                baseIndent = #indent
            end
            
            -- If indentation matches the block level, compile this line
            if #indent >= baseIndent then
                local blockTokens = tokenizer.tokenize(trimmed)
                if #blockTokens > 0 then
                    -- Check for return statement
                    if blockTokens[1] == "return" then
                        -- Compile return expression
                        if #blockTokens > 1 then
                            local returnTokens = {}
                            for i = 2, #blockTokens do
                                table.insert(returnTokens, blockTokens[i])
                            end
                            compileExpression(functionState, returnTokens, 1)
                        else
                            -- Return None
                            local constIndex = addConstant(functionState, nil)
                            emit(functionState, opcodes.Opcodes.LOAD_CONST, constIndex)
                        end
                        emit(functionState, opcodes.Opcodes.RETURN_VALUE)
                    else
                        -- Regular statement in function body
                        functionState.lineNumber = currentLine
                        compileStatement(functionState, blockTokens, 1)
                    end
                    currentLine = currentLine + 1
                else
                    currentLine = currentLine + 1
                end
            else
                -- Indentation decreased, end of function body
                break
            end
        else
            -- No indentation, end of function body
            break
        end
    end
    
    -- If no explicit return, add implicit return None
    if #functionState.code == 0 or functionState.code[#functionState.code].op ~= opcodes.Opcodes.RETURN_VALUE then
        local constIndex = addConstant(functionState, nil)
        emit(functionState, opcodes.Opcodes.LOAD_CONST, constIndex)
        emit(functionState, opcodes.Opcodes.RETURN_VALUE)
    end
      -- Create MAKE_FUNCTION instruction with complete function bytecode
    local nameIndex = addName(state, functionName)
    local instruction = {
        op = opcodes.Opcodes.MAKE_FUNCTION,
        name = functionName,
        parameters = parameters,
        bytecode = {
            constants = functionState.constants,
            names = functionState.names,
            code = functionState.code
        },
        defaults = {},
        closure = {},
        arg = nameIndex, -- Use nameIndex as the arg for consistency
        line = state.lineNumber
    }
    table.insert(state.code, instruction)
    
    -- Store function in variable
    emit(state, opcodes.Opcodes.STORE_NAME, nameIndex)
    
    return currentLine
end

-- Compile an if/elif/else statement with blocks
compileIfStatementBlock = function(state: CompilerState, lines: {string}, startLine: number): number
    local endJumps = {}  -- Jumps to the end of the entire if statement
    local currentLine = startLine
    local isFirstClause = true
    
    while currentLine <= #lines do
        local line = lines[currentLine]
        local trimmedLine = line:match("^%s*(.-)%s*$") or ""
        local tokens = tokenizer.tokenize(trimmedLine)
        
        if #tokens == 0 then
            currentLine = currentLine + 1
            break
        end
        
        local keyword = tokens[1]
        
        if keyword == "if" or keyword == "elif" then
            -- Parse: if/elif condition:
            local conditionTokens = {}
            local pos = 2
            while pos <= #tokens and tokens[pos] ~= ":" do
                table.insert(conditionTokens, tokens[pos])
                pos = pos + 1
            end
            
            if pos > #tokens or tokens[pos] ~= ":" then
                error("Expected ':' after " .. keyword .. " condition")
            end
            
            if #conditionTokens == 0 then
                error(keyword .. " statement must have a condition")
            end
            
            -- Compile the condition expression
            compileExpression(state, conditionTokens, 1)
            
            -- Jump if condition is false (will patch target later)
            emit(state, opcodes.Opcodes.JUMP_IF_FALSE, 0)
            local conditionJump = #state.code - 1
            
            -- Compile the indented block for this if/elif
            currentLine = currentLine + 1
            local baseIndent = nil
            
            while currentLine <= #lines do
                local blockLine = lines[currentLine]
                local indent = blockLine:match("^(%s*)") or ""
                local trimmed = blockLine:match("^%s*(.-)%s*$") or ""
                
                -- Skip empty lines
                if trimmed == "" then
                    currentLine = currentLine + 1
                elseif #indent > 0 then
                    -- First indented line sets the base indentation
                    if not baseIndent then
                        baseIndent = #indent
                    end
                    -- If indentation matches the block level, compile this line
                    if #indent >= baseIndent then
                        local blockTokens = tokenizer.tokenize(trimmed)
                        if #blockTokens > 0 then
                            -- Check if this is a nested control structure
                            if blockTokens[1] == "if" then
                                -- Handle nested if statement
                                currentLine = compileIfStatementBlock(state, lines, currentLine)
                            elseif blockTokens[1] == "while" then
                                -- Handle nested while loop
                                currentLine = compileWhileLoopBlock(state, lines, currentLine)
                            elseif blockTokens[1] == "for" then
                                -- Handle nested for loop
                                currentLine = compileForLoopBlock(state, lines, currentLine)
                            else
                                -- Regular statement
                                state.lineNumber = currentLine
                                compileStatement(state, blockTokens, 1)
                                currentLine = currentLine + 1
                            end
                        else
                            currentLine = currentLine + 1
                        end
                    else
                        -- Indentation decreased, end of block
                        break
                    end
                else
                    -- No indentation, check if it's elif/else
                    local nextTokens = tokenizer.tokenize(trimmed)
                    if nextTokens[1] == "elif" or nextTokens[1] == "else" then
                        break  -- Continue to handle elif/else
                    else
                        break  -- End of if statement
                    end
                end
            end
            
            -- After the block, jump to the end of the entire if statement
            -- (to skip other elif/else clauses)
            emit(state, opcodes.Opcodes.JUMP, 0)
            table.insert(endJumps, #state.code - 1)
            
            -- Patch the condition jump to point here (start of next clause)
            local nextClauseTarget = #state.code
            state.code[conditionJump + 1].arg = nextClauseTarget
            
            -- Check if we have more elif/else clauses
            if currentLine <= #lines then
                local nextLine = lines[currentLine]
                if nextLine then
                    local nextTrimmed = nextLine:match("^%s*(.-)%s*$") or ""
                    local nextTokens = tokenizer.tokenize(nextTrimmed)
                    if nextTokens[1] == "elif" or nextTokens[1] == "else" then
                        -- Continue with next clause
                        isFirstClause = false
                    else
                        -- End of if statement
                        break
                    end
                else
                    break
                end
            else
                break
            end
            
        elseif keyword == "else" then
            -- Parse: else:
            if #tokens < 2 or tokens[2] ~= ":" then
                error("Expected ':' after else")
            end
            
            -- Compile the else block
            currentLine = currentLine + 1
            local baseIndent = nil
            
            while currentLine <= #lines do
                local blockLine = lines[currentLine]
                local indent = blockLine:match("^(%s*)") or ""
                local trimmed = blockLine:match("^%s*(.-)%s*$") or ""
                
                -- Skip empty lines
                if trimmed == "" then
                    currentLine = currentLine + 1
                elseif #indent > 0 then
                    -- First indented line sets the base indentation
                    if not baseIndent then
                        baseIndent = #indent
                    end
                    -- If indentation matches the block level, compile this line
                    if #indent >= baseIndent then
                        local blockTokens = tokenizer.tokenize(trimmed)
                        if #blockTokens > 0 then
                            -- Check if this is a nested control structure
                            if blockTokens[1] == "if" then
                                -- Handle nested if statement
                                currentLine = compileIfStatementBlock(state, lines, currentLine)
                            elseif blockTokens[1] == "while" then
                                -- Handle nested while loop
                                currentLine = compileWhileLoopBlock(state, lines, currentLine)
                            elseif blockTokens[1] == "for" then
                                -- Handle nested for loop
                                currentLine = compileForLoopBlock(state, lines, currentLine)
                            else
                                -- Regular statement
                                state.lineNumber = currentLine
                                compileStatement(state, blockTokens, 1)
                                currentLine = currentLine + 1
                            end
                        else
                            currentLine = currentLine + 1
                        end
                    else
                        -- Indentation decreased, end of block
                        break
                    end
                else
                    -- No indentation, end of else block
                    break
                end
            end
            
            break  -- else is always the last clause
        else
            break  -- Not an if/elif/else statement
        end
    end
    
    -- Patch all the "jump to end" instructions to point to the end
    local endTarget = #state.code
    for _, jumpIndex in ipairs(endJumps) do
        state.code[jumpIndex + 1].arg = endTarget
    end
    
    return currentLine
end

-- Compile a while loop with a block of statements
compileWhileLoopBlock = function(state: CompilerState, lines: {string}, startLine: number): number
    local line = lines[startLine]
    local trimmedLine = line:match("^%s*(.-)%s*$") or ""
    local tokens = tokenizer.tokenize(trimmedLine)
    
    -- Parse: while condition:
    if tokens[1] ~= "while" then
        error("Expected 'while' keyword")
    end
    
    -- Parse the condition expression (everything until ':')
    local conditionTokens = {}
    local pos = 2
    while pos <= #tokens and tokens[pos] ~= ":" do
        table.insert(conditionTokens, tokens[pos])
        pos = pos + 1
    end
    
    if tokens[pos] ~= ":" then
        error("Expected ':' after while condition")
    end
    
    if #conditionTokens == 0 then
        error("While loop must have a condition")
    end
    
    -- Mark the loop start position (where we'll jump back to)
    local loopStart = #state.code
    
    -- Compile the condition expression
    compileExpression(state, conditionTokens, 1)
    
    -- Jump if condition is false (will patch the target later)
    emit(state, opcodes.Opcodes.JUMP_IF_FALSE, 0)
    local exitJumpInstruction = #state.code - 1
    
    -- Find and compile the indented block
    local currentLine = startLine + 1
    local baseIndent = nil
    
    while currentLine <= #lines do
        local blockLine = lines[currentLine]
        local indent = blockLine:match("^(%s*)") or ""
        local trimmed = blockLine:match("^%s*(.-)%s*$") or ""
        
        -- Skip empty lines
        if trimmed == "" then
            currentLine = currentLine + 1
        -- Check if this line is part of the block
        elseif #indent > 0 then
            -- First indented line sets the base indentation
            if not baseIndent then
                baseIndent = #indent
            end
            -- If indentation matches the block level, compile this line
            if #indent >= baseIndent then
                local blockTokens = tokenizer.tokenize(trimmed)
                if #blockTokens > 0 then
                    -- Check if this is a nested control structure
                    if blockTokens[1] == "if" then
                        -- Handle nested if statement
                        currentLine = compileIfStatementBlock(state, lines, currentLine)
                    elseif blockTokens[1] == "while" then
                        -- Handle nested while loop
                        currentLine = compileWhileLoopBlock(state, lines, currentLine)
                    elseif blockTokens[1] == "for" then
                        -- Handle nested for loop
                        currentLine = compileForLoopBlock(state, lines, currentLine)
                    else
                        -- Regular statement
                        state.lineNumber = currentLine
                        compileStatement(state, blockTokens, 1)
                        currentLine = currentLine + 1
                    end
                else
                    currentLine = currentLine + 1
                end
            else
                -- Indentation decreased, end of block
                break
            end
        else
            -- No indentation, end of block
            break
        end
    end
    
    -- Jump back to the beginning of the loop
    emit(state, opcodes.Opcodes.JUMP, loopStart)
    
    -- Patch the exit jump target
    local exitTarget = #state.code
    state.code[exitJumpInstruction + 1].arg = exitTarget
    
    return currentLine
end

-- Compile a for loop with a block of statements  
compileForLoopBlock = function(state: CompilerState, lines: {string}, startLine: number): number
    local line = lines[startLine]
    local trimmedLine = line:match("^%s*(.-)%s*$") or ""
    local tokens = tokenizer.tokenize(trimmedLine)
    
    -- Parse: for var in iterable:
    if tokens[1] ~= "for" then
        error("Expected 'for' keyword")
    end
    
    -- Get the loop variable name
    local loopVar = tokens[2]
    if not isIdentifier(loopVar) then
        error("Expected variable name after 'for'")
    end
    
    -- Expect 'in'
    if tokens[3] ~= "in" then
        error("Expected 'in' after loop variable")
    end
    
    -- Parse the iterable expression (rest of the tokens until ':')
    local iterableTokens = {}
    local pos = 4
    while pos <= #tokens and tokens[pos] ~= ":" do
        table.insert(iterableTokens, tokens[pos])
        pos = pos + 1
    end
    
    if tokens[pos] ~= ":" then
        error("Expected ':' after for loop expression")
    end
    
    -- Compile the iterable expression
    compileExpression(state, iterableTokens, 1)
    
    -- Get iterator from the iterable
    emit(state, opcodes.Opcodes.GET_ITER)
    
    -- Mark the loop start position
    local loopStart = #state.code
    
    -- Try to get next value from iterator
    emit(state, opcodes.Opcodes.FOR_ITER, 0) -- Will patch jump target later
    local forIterInstruction = #state.code - 1
    
    -- Store the loop value in the loop variable
    local loopVarIndex = addName(state, loopVar)
    emit(state, opcodes.Opcodes.STORE_NAME, loopVarIndex)
    
    -- Find and compile the indented block
    local currentLine = startLine + 1
    local baseIndent = nil
    
    while currentLine <= #lines do
        local blockLine = lines[currentLine]
        local indent = blockLine:match("^(%s*)") or ""
        local trimmed = blockLine:match("^%s*(.-)%s*$") or ""
        
        -- Skip empty lines
        if trimmed == "" then
            currentLine = currentLine + 1
        -- Check if this line is part of the block
        elseif #indent > 0 then
            -- First indented line sets the base indentation
            if not baseIndent then
                baseIndent = #indent
            end
              -- If indentation matches the block level, compile this line
            if #indent >= baseIndent then
                local blockTokens = tokenizer.tokenize(trimmed)
                if #blockTokens > 0 then
                    -- Check if this is a nested control structure
                    if blockTokens[1] == "if" then
                        -- Handle nested if statement
                        currentLine = compileIfStatementBlock(state, lines, currentLine)
                    elseif blockTokens[1] == "while" then
                        -- Handle nested while loop
                        currentLine = compileWhileLoopBlock(state, lines, currentLine)
                    elseif blockTokens[1] == "for" then
                        -- Handle nested for loop
                        currentLine = compileForLoopBlock(state, lines, currentLine)
                    else
                        -- Regular statement
                        state.lineNumber = currentLine
                        compileStatement(state, blockTokens, 1)
                        currentLine = currentLine + 1
                    end
                else
                    currentLine = currentLine + 1
                end
            else
                -- Indentation decreased, end of block
                break
            end
        else
            -- No indentation, end of block
            break
        end
    end
    
    -- Jump back to loop start
    emit(state, opcodes.Opcodes.JUMP, loopStart)
    
    -- Patch the FOR_ITER jump target to exit the loop
    local exitTarget = #state.code
    state.code[forIterInstruction + 1].arg = exitTarget
    
    return currentLine
end

-- Compile a for loop statement
local function compileForLoop(state, tokens, pos)
    -- for var in iterable:
    if tokens[pos] ~= "for" then
        error("Expected 'for' keyword")
    end
    pos = pos + 1
    
    -- Get the loop variable name
    local loopVar = tokens[pos]
    if not isIdentifier(loopVar) then
        error("Expected variable name after 'for'")
    end
    pos = pos + 1
    
    -- Expect 'in'
    if tokens[pos] ~= "in" then
        error("Expected 'in' after loop variable")
    end
    pos = pos + 1
    
    -- Compile the iterable expression
    pos = compileExpression(state, tokens, pos)
    
    -- Expect ':'
    if tokens[pos] ~= ":" then
        error("Expected ':' after for loop expression")
    end
    pos = pos + 1
    
    -- Get iterator from the iterable
    emit(state, opcodes.Opcodes.GET_ITER)
    
    -- Mark the loop start position
    local loopStart = #state.code
    
    -- Try to get next value from iterator
    emit(state, opcodes.Opcodes.FOR_ITER, 0) -- Will patch jump target later
    local forIterInstruction = #state.code - 1
    
    -- Store the loop value in the loop variable
    local loopVarIndex = addName(state, loopVar)
    emit(state, opcodes.Opcodes.STORE_NAME, loopVarIndex)
    
    -- For now, we'll create a simple placeholder loop body
    -- In a full implementation, we'd need to parse indented blocks
    -- But for testing, let's assume single-line loop bodies
    
    -- Jump back to loop start
    emit(state, opcodes.Opcodes.JUMP, loopStart)
    
    -- Patch the FOR_ITER jump target to exit the loop
    local exitTarget = #state.code
    state.code[forIterInstruction + 1].arg = exitTarget
    
    return pos
end

-- Compile a single statement
compileStatement = function(state: CompilerState, tokens: {string}, pos: TokenPosition): TokenPosition    if not tokens[pos] then
        return pos
    end
      -- Check for control flow statements
    if tokens[pos] == "for" then
        return compileForLoop(state, tokens, pos)
    elseif tokens[pos] == "def" then
        return compileFunctionDefinition(state, tokens, pos)
    -- Check if this is an assignment (variable = expression OR obj[key] = expression)
    elseif isIdentifier(tokens[pos]) then
        -- Look ahead to determine if this is an assignment
        local checkPos = pos + 1
        local foundEquals = false
        
        -- Scan forward to look for '=' (allowing for indexing syntax)
        while checkPos <= #tokens do
            if tokens[checkPos] == "=" then
                foundEquals = true
                break
            elseif tokens[checkPos] == "(" then
                -- If we hit a function call, it's not an assignment
                break
            end
            checkPos = checkPos + 1
        end
        
        if foundEquals then
            return compileAssignment(state, tokens, pos)
        else
            -- Expression statement (like function calls)
            pos = compileExpression(state, tokens, pos)
            -- Pop the result since it's not being assigned
            emit(state, opcodes.Opcodes.POP_TOP)
            return pos
        end
    else
        -- Expression statement (like function calls)
        pos = compileExpression(state, tokens, pos)
        -- Pop the result since it's not being assigned
        emit(state, opcodes.Opcodes.POP_TOP)
        return pos
    end
end

-- Main compilation function
function Compiler.compile(sourceCode: string): Bytecode
    local state = createCompilerState()
    
    -- Split source code into lines
    local lines: {string} = {}
    for line in sourceCode:gmatch("[^\r\n]+") do
        table.insert(lines, line)
    end
    local i = 1
    while i <= #lines do
        state.lineNumber = i
        local line = lines[i]
        local trimmed = line:match("^%s*(.-)%s*$") or ""
        
        if trimmed ~= "" and not trimmed:match("^#") then  -- Skip empty lines and comments
            local tokens = tokenizer.tokenize(trimmed)
            
            -- Check if this line has unclosed delimiters (multi-line statement)
            if #tokens > 0 and hasUnclosedDelimiters(tokens) then
                -- Collect all tokens for the complete multi-line statement
                local completeTokens, endLine = collectMultiLineStatement(lines, i)
                compileStatement(state, completeTokens, 1)
                i = endLine + 1
            elseif #tokens > 0 then                -- Check if this is a for loop
                if tokens[1] == "for" then
                    i = compileForLoopBlock(state, lines, i)
                -- Check if this is a while loop
                elseif tokens[1] == "while" then
                    i = compileWhileLoopBlock(state, lines, i)
                -- Check if this is an if statement
                elseif tokens[1] == "if" then
                    i = compileIfStatementBlock(state, lines, i)
                -- Check if this is a function definition
                elseif tokens[1] == "def" then
                    i = compileFunctionDefinitionBlock(state, lines, i)
                else
                    compileStatement(state, tokens, 1)
                    i = i + 1
                end
            else
                i = i + 1
            end
        else
            i = i + 1
        end
    end
    
    -- Return the bytecode structure
    local result: Bytecode = {
        constants = state.constants,
        names = state.names,
        code = state.code,
        sourceLines = lines  -- For debugging
    }
    return result
end

return Compiler
